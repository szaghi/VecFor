import{_ as t,o,c as r,a2 as d}from"./chunks/framework.Co-JkuWq.js";const h=JSON.parse('{"title":"Features","description":"","frontmatter":{"title":"Features"},"headers":[],"relativePath":"guide/features.md","filePath":"guide/features.md"}'),a={name:"guide/features.md"};function i(c,e,l,n,s,p){return o(),r("div",null,[...e[0]||(e[0]=[d('<h1 id="features" tabindex="-1">Features <a class="header-anchor" href="#features" aria-label="Permalink to &quot;Features&quot;">​</a></h1><h2 id="vectorial-calculus-algebra" tabindex="-1">Vectorial Calculus Algebra <a class="header-anchor" href="#vectorial-calculus-algebra" aria-label="Permalink to &quot;Vectorial Calculus Algebra&quot;">​</a></h2><ul><li>Cross product via <code>.cross.</code> infix operator</li><li>Dot product via <code>.dot.</code> infix operator</li><li>Parallel projection via <code>.paral.</code> infix operator</li><li>Orthogonal projection via <code>.ortho.</code> infix operator</li><li>Matrix product via <code>.matrix.</code> infix operator</li><li>Triangle face normals: <code>face_normal3</code> (also as stand-alone procedure)</li><li>Quad face normals: <code>face_normal4</code> (also as stand-alone procedure) — norm equals face area</li></ul><h2 id="arithmetic-operators" tabindex="-1">Arithmetic Operators <a class="header-anchor" href="#arithmetic-operators" aria-label="Permalink to &quot;Arithmetic Operators&quot;">​</a></h2><p>All standard operators work between two vectors and between a vector and any scalar:</p><ul><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> between two <code>vector</code> objects</li><li><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> between a <code>vector</code> and a numeric scalar of any supported kind (left and right)</li><li>Unary <code>+</code> and <code>-</code></li><li>All operators resolved at compile time via generic interfaces — no runtime dispatch overhead</li></ul><h2 id="comparison-operators" tabindex="-1">Comparison Operators <a class="header-anchor" href="#comparison-operators" aria-label="Permalink to &quot;Comparison Operators&quot;">​</a></h2><p>Vectors are compared by their L2 norm:</p><ul><li><code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>/=</code>, <code>&gt;=</code>, <code>&gt;</code> — work between two vectors and between a vector and any numeric scalar</li></ul><h2 id="geometry-methods" tabindex="-1">Geometry Methods <a class="header-anchor" href="#geometry-methods" aria-label="Permalink to &quot;Geometry Methods&quot;">​</a></h2><ul><li><code>normL2()</code> — Euclidean (L2) norm</li><li><code>sq_norm()</code> — squared norm (avoids a square root when only ordering is needed)</li><li><code>normalize()</code> — normalize the vector in-place (subroutine); falls back to zero vector if norm is zero</li><li><code>normalized()</code> — return the normalized vector (function)</li><li><code>angle(vec)</code> — angle between two vectors in radians</li><li><code>rotate(axis, angle)</code> — rotate the vector around a given axis by the given angle</li><li><code>mirror(plane_normal)</code> — mirror the vector across a plane defined by its normal</li><li><code>distance_to_line(pt, dir)</code> — distance from the vector (treated as a point) to a line</li><li><code>distance_to_plane(pt, normal)</code> — distance from the vector to a plane</li><li><code>projection_onto_plane(normal)</code> — orthogonal projection onto a plane</li><li><code>is_collinear(v1, v2)</code> — test collinearity of three vectors (as points)</li><li><code>is_concyclic(v1, v2, v3)</code> — test whether four vectors lie on a common circle</li></ul><h2 id="i-o-and-printing" tabindex="-1">I/O and Printing <a class="header-anchor" href="#i-o-and-printing" aria-label="Permalink to &quot;I/O and Printing&quot;">​</a></h2><ul><li><code>print</code> — formatted output of x, y, z components to any Fortran unit</li><li><code>save</code> / <code>load</code> — binary I/O for vector data (sequential and stream access)</li><li><code>iolen()</code> — returns the record length needed for direct-access I/O</li></ul><h2 id="multi-precision-support" tabindex="-1">Multi-Precision Support <a class="header-anchor" href="#multi-precision-support" aria-label="Permalink to &quot;Multi-Precision Support&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Type</th><th>Kind</th><th>Precision</th></tr></thead><tbody><tr><td><code>vector</code> / <code>vector_R8P</code></td><td><code>R8P = selected_real_kind(15,307)</code></td><td>64-bit, ~15 digits</td></tr><tr><td><code>vector_R4P</code></td><td><code>R4P = selected_real_kind(6,37)</code></td><td>32-bit, ~6 digits</td></tr><tr><td><code>vector_R16P</code></td><td><code>R16P = selected_real_kind(33,4931)</code></td><td>128-bit, ~33 digits (if compiler supports it)</td></tr></tbody></table><p>The single <code>use vecfor</code> statement re-exports all precision variants and the corresponding Cartesian versors (<code>ex</code>, <code>ey</code>, <code>ez</code> for each kind).</p><h2 id="mixed-kind-operands" tabindex="-1">Mixed-Kind Operands <a class="header-anchor" href="#mixed-kind-operands" aria-label="Permalink to &quot;Mixed-Kind Operands&quot;">​</a></h2><p>All operators accept mixed-kind arguments. Supported scalar kinds:</p><table tabindex="0"><thead><tr><th>Kind</th><th>Type</th><th>Width</th></tr></thead><tbody><tr><td><code>R16P</code></td><td>real</td><td>128-bit</td></tr><tr><td><code>R8P</code></td><td>real</td><td>64-bit</td></tr><tr><td><code>R4P</code></td><td>real</td><td>32-bit</td></tr><tr><td><code>I8P</code></td><td>integer</td><td>64-bit</td></tr><tr><td><code>I4P</code></td><td>integer</td><td>32-bit</td></tr><tr><td><code>I2P</code></td><td>integer</td><td>16-bit</td></tr><tr><td><code>I1P</code></td><td>integer</td><td>8-bit</td></tr></tbody></table><h2 id="compiler-support" tabindex="-1">Compiler Support <a class="header-anchor" href="#compiler-support" aria-label="Permalink to &quot;Compiler Support&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Compiler</th><th>Status</th></tr></thead><tbody><tr><td>GNU gfortran ≥ 4.9.2</td><td>Supported</td></tr><tr><td>Intel Fortran ≥ 12.x</td><td>Supported</td></tr><tr><td>NVIDIA nvfortran</td><td>Supported</td></tr><tr><td>IBM XL Fortran</td><td>Not tested</td></tr><tr><td>g95</td><td>Not tested</td></tr><tr><td>NAG Fortran</td><td>Not tested</td></tr></tbody></table><h2 id="design-principles" tabindex="-1">Design Principles <a class="header-anchor" href="#design-principles" aria-label="Permalink to &quot;Design Principles&quot;">​</a></h2><ul><li><strong>Pure Fortran</strong> — no C extensions, no system calls beyond standard I/O</li><li><strong>OOP</strong> — a single <code>vector</code> derived type exposes all functionality as type-bound procedures and operators</li><li><strong>TDD</strong> — every public procedure is exercised by automated doctests in <code>src/tests/</code></li><li><strong>KISS</strong> — simple, focused API; the entire library fits in one file</li><li><strong>Thread-safe</strong> — all procedures are <code>pure</code> or <code>elemental</code></li><li><strong>Free &amp; Open Source</strong> — multi-licensed for FOSS and commercial use</li></ul>',23)])])}const m=t(a,[["render",i]]);export{h as __pageData,m as default};
